
# app.R
# Shiny Data Entry App generated by ChatGPT
# - Reads "2025_updated_U20_checklist.xlsx" in the same folder
# - Creates a tab per sheet with editable tables
# - Allows adding/removing rows
# - Saves to /data as CSV per sheet and an "all_sheets_combined.csv"

library(shiny)
library(readxl)
library(DT)
library(dplyr)
library(stringr)
library(purrr)
library(glue)

# ---- Config ----
excel_file <- "2025_updated_U20_checklist.xlsx"
data_dir   <- "data"
if (!dir.exists(data_dir)) dir.create(data_dir, recursive = TRUE)

# ---- Helpers ----
safe_read_sheets <- function(path) {
  stopifnot(file.exists(path))
  sheets <- readxl::excel_sheets(path)
  dfs <- purrr::map(sheets, function(sh) {
    # read as character to avoid type issues for data entry
    suppressWarnings(readxl::read_excel(path, sheet = sh, .name_repair = "minimal", col_types = "text"))
  })
  names(dfs) <- sheets
  dfs
}

# Load or initialize data frames: if a CSV exists for a sheet, use it;
# otherwise load from Excel.
load_state <- function() {
  excel_dfs <- safe_read_sheets(excel_file)
  out <- list()
  for (nm in names(excel_dfs)) {
    csv_path <- file.path(data_dir, paste0(nm, ".csv"))
    if (file.exists(csv_path)) {
      df <- suppressWarnings(read.csv(csv_path, check.names = FALSE, stringsAsFactors = FALSE))
      # Keep character for editing
      df <- mutate(across(everything(), as.character), .data = df)
      out[[nm]] <- df
    } else {
      df <- excel_dfs[[nm]]
      df <- mutate(across(everything(), as.character), .data = df)
      out[[nm]] <- df
    }
  }
  out
}

save_sheet_csv <- function(name, df) {
  # sanitize filename
  fname <- paste0(name, ".csv")
  write.csv(df, file.path(data_dir, fname), row.names = FALSE, na = "")
}

# Combine all sheets to one long CSV (with sheet name)
combine_all <- function(all) {
  purrr::imap_dfr(all, ~ mutate(.x, .sheet = .y)) %>%
    relocate(.sheet, .before = 1)
}

# Initialize reactive state from Excel or prior CSVs
init_state <- load_state()

# ---- UI ----
ui <- navbarPage(
  title = "U20 Checklist — Data Entry",
  tabPanel("Home",
           fluidPage(
             h3("Welcome"),
             p("This app lets you enter and edit data directly in each sheet's table."),
             tags$ul(
               tags$li("Click a sheet tab to edit its table."),
               tags$li("Double-click a cell to edit. Use the buttons to add or delete rows."),
               tags$li("Click 'Save This Sheet' to write changes to CSV in the ./data folder."),
               tags$li("Use 'Export All Sheets' to download a single combined CSV.")
             ),
             tags$hr(),
             h4("Workbook Summary"),
             verbatimTextOutput("summary_text"),
             tags$hr(),
             h4("Global Actions"),
             downloadButton("export_all_btn", "Export All Sheets (combined CSV)"),
             actionButton("save_all_btn", "Save All Sheets to ./data", class = "btn-primary")
           )
  ),
  # Dynamic tabs for each sheet created server-side
  id = "main_nav"
)

# ---- Server ----
server <- function(input, output, session) {
  # Reactive state: a named list of data frames (one per sheet)
  r_all <- reactiveVal(init_state)
  sheet_names <- names(init_state)

  # Build a summary for home tab
  output$summary_text <- renderText({
    all <- r_all()
    paste0(
      purrr::imap_chr(all, function(df, nm) {
        glue("- {nm}: {nrow(df)} rows × {ncol(df)} cols")
      }) %>% paste(collapse = "\n")
    )
  })

  # Create a tab for each sheet dynamically
  observe({
    for (nm in sheet_names) {
      tab_id <- paste0("tab_", nm)
      # If tab doesn't exist yet, add it
      if (is.null(shiny::tabPanelBody(tab_id))) {
        appendTab(
          inputId = "main_nav",
          tabPanel(
            title = nm,
            value = tab_id,
            fluidPage(
              fluidRow(
                column(12,
                       div(style = "display:flex; gap:8px; margin-bottom:8px;",
                           actionButton(paste0("add_row_", nm), "Add Row"),
                           actionButton(paste0("del_row_", nm), "Delete Selected"),
                           actionButton(paste0("save_sheet_", nm), "Save This Sheet", class = "btn-success")
                       ),
                       DTOutput(paste0("table_", nm)),
                       br(),
                       p(em("Tip: Click row header to select rows for deletion."))
                )
              )
            )
          )
        )
      }
    }
  })

  # For each sheet, create DT proxy, render, and handlers
  purrr::walk(sheet_names, function(nm) {
    tbl_id <- paste0("table_", nm)
    proxy  <- dataTableProxy(tbl_id)

    output[[tbl_id]] <- renderDT({
      df <- r_all()[[nm]]
      datatable(
        df,
        rownames = TRUE,
        editable = "cell",
        selection = list(mode = "multiple", target = "row"),
        options = list(scrollX = TRUE, pageLength = 25)
      )
    }, server = TRUE)

    # Cell edits
    observeEvent(input[[paste0(tbl_id, "_cell_edit")]], {
      info <- input[[paste0(tbl_id, "_cell_edit")]]
      all <- r_all()
      df <- all[[nm]]
      i <- info$row; j <- info$col; v <- info$value
      # DT includes rownames; adjust if necessary
      if (!is.null(j) && j >= 0 && j <= ncol(df)) {
        df[i, j] <- v
        all[[nm]] <- df
        r_all(all)
        replaceData(proxy, df, resetPaging = FALSE)
      }
    })

    # Add row
    observeEvent(input[[paste0("add_row_", nm)]], {
      all <- r_all()
      df <- all[[nm]]
      new_row <- as.list(rep("", ncol(df)))
      df <- bind_rows(df, new_row)
      names(df) <- names(all[[nm]]) # keep names
      all[[nm]] <- df
      r_all(all)
      replaceData(proxy, df, resetPaging = FALSE)
    })

    # Delete selected rows
    observeEvent(input[[paste0("del_row_", nm)]], {
      all <- r_all()
      df <- all[[nm]]
      sel <- input[[tbl_id]]_rows_selected
      if (length(sel) > 0) {
        df <- df[-sel, , drop = FALSE]
        all[[nm]] <- df
        r_all(all)
        replaceData(proxy, df, resetPaging = FALSE, rownames = TRUE)
      }
    })

    # Save this sheet
    observeEvent(input[[paste0("save_sheet_", nm)]], {
      all <- r_all()
      df <- all[[nm]]
      save_sheet_csv(nm, df)
      showNotification(glue("Saved '{nm}' to ./data/{nm}.csv"), type = "message")
    })
  })

  # Save all sheets to ./data
  observeEvent(input$save_all_btn, {
    all <- r_all()
    purrr::iwalk(all, ~ save_sheet_csv(.y, .x))
    showNotification("Saved all sheets to ./data as CSV.", type = "message")
  })

  # Export all sheets combined (download)
  output$export_all_btn <- downloadHandler(
    filename = function() paste0("U20_checklist_combined_", format(Sys.time(), "%Y%m%d-%H%M%S"), ".csv"),
    content = function(file) {
      all <- r_all()
      combo <- combine_all(all)
      write.csv(combo, file, row.names = FALSE, na = "")
    }
  )
}

shinyApp(ui, server)
